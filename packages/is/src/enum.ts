/**
 * @module enum
 *
 * This module exports a function named {@linkcode isEnum}, to check if a given
 * value appears to be a TypeScript `enum` object. It also exports a type named
 * {@linkcode IsEnum}, which is a type-level equivalent of `isEnum`, allowing
 * you to easily construct conditional type constraints in your own code.
 *
 * ```ts
 * import { isEnum } from "@type/is/enum";
 *
 * enum Foo {
 *   Bar,
 *   Baz,
 *   Qux,
 * }
 *
 * isEnum(Foo); // true
 *
 * const obj = { Bar: 0, Baz: 1, Qux: 2 };
 * isEnum(obj); // false
 * ```
 * @category Objects
 */
const Object = globalThis.Object;
const ObjectPrototype = Object.prototype;
const ObjectKeys = Object.keys as <T>(o: T) => (string & keyof T)[];
// const ObjectValues = Object.values;
const ObjectGetPrototypeOf = Object.getPrototypeOf;

/**
 * Check if the given value appears to be a TypeScript `enum` object, which is
 * a plain object with either all string keys that point to numeric or string
 * values, or string/numeric keys that point to string/numeric values, which
 * are inversely mapped to each other (e.g. `A.B === 1 && A[1] === "B"`).
 *
 * @param it The value to check.
 * @returns `true` if the value appears to be a TypeScript `enum` object,
 * `false` otherwise.
 * @example
 * ```ts
 * import { isEnum } from "@type/is/enum";
 *
 * enum Foo {
 *   Bar, // 0
 *   Baz, // 1
 *   Qux, // 2
 *   // implicit reverse mapping:
 *   // 0: "Bar", 1: "Baz", 2: "Qux",
 * }
 *
 * isEnum(Foo); // true
 *
 * const obj = { Bar: 0, Baz: 1, Qux: 2 };
 * isEnum(obj); // false
 * ```
 * @category Objects
 */
export function isEnum<T extends EnumLike = EnumLike>(
  // deno-lint-ignore ban-types
  it: T | {} | null | undefined,
): it is Enum<T>;
export function isEnum<T extends EnumLike = EnumLike>(
  it: unknown,
): it is Enum<T>;
/** @internal */
export function isEnum(it: unknown): it is Enum {
  return typeof it === "object" && it != null && (
    ObjectGetPrototypeOf(it) === ObjectPrototype ||
    ObjectGetPrototypeOf(it) === null
  ) &&
    ObjectKeys(it).every((k) =>
      (typeof k === "string" && +k !== +k) && (
          typeof it[k] === "number" || typeof it[k] === "string"
        ) || +k === +k && typeof it[k] === "string"
    );
}

/**
 * Represents an "enum-like" object, which is a plain object composed of either
 * all string keys and string values, or a two-way mapping of string keys to
 * numeric values (and vice versa).
 *
 * This is a supertype of the type of object created by TypeScript's builtin
 * `enum` keyword. Its primary consumer is the {@linkcode isEnum} function.
 *
 * @category Types
 * @tags enum, objects
 * @example
 * ```ts
 * // when we create an enum with constant numeric values, the TypeScript
 * // compiler auto-generates an implicit reverse-mapping from the values
 * // back to their respective keys, providing us with the capability to
 * // access the keys by their values.
 * enum Priority {
 *   Low = 0x0,
 *   Medium = 0x1,
 *   High = 0x2,
 *   Insane = 0xFF,
 * }
 *
 * // the actual object generated by the enum syntax above looks like this:
 * const Priority = {
 *   Low: 0,
 *   Medium: 1,
 *   High: 2,
 *   Insane: 255,
 *   "0": "Low",
 *   "1": "Medium",
 *   "2": "High",
 *   "255": "Insane",
 * } satisfies EnumLike
 *
 * // this provides us with the ability to access a key even when we only have
 * // its value, a language feature that is popular in other OOP languages such
 * // as C#, Java, and C++:
 *
 * console.log(Priority.High); // 2
 * console.log(Priority[2]); // "High"
 * console.assert(Priority.High === Priority[Priority[2]]);
 * console.assert(Priority[2] === Priority[Priority.High]);
 * ```
 */
export interface EnumLike<
  K extends string | number = string | number,
  V extends string | number = string | number,
> {
  /**
   * Represents the string keys of the enum-like object, mapped either to
   * literal string or numeric values, or to `undefined` (for assignability
   * purposes only; in practice, no enum-like object in the wild has values of
   * `undefined`).
   * @readonly
   */
  readonly [key: string]: K | V | undefined;

  /**
   * Represents numeric "indices" of the enum-like object, which are actually a
   * reverse-mapping of an enum's numeric values back to their respective keys.
   *
   * See the examples on the {@linkcode isEnum} guard and {@linkcode EnumLike}
   * interface for reference and further demonstration of this behavior.
   *
   * @readonly
   */
  readonly [index: number]: K;
}

/**
 * Represents a TypeScript `enum` object, which is defined as a plain object
 * that satisfies one of the following conditions:
 *
 * - String or numeric keys mapped to string or numeric values.
 * - Values can be constant or computed.
 *
 * > Declared keys may only be literal static strings. Numeric keys are not
 * > allowed in the declaration of an enum. The only legal way to create an
 * > enum with numeric keys like `"0"` is for the compiler to generate them.
 *
 * String-to-string enums **may not** have reverse mappings. It is only
 * supported for constant numeric values (whether explicitly specified via
 * initializers, or implicitly assigned by the TS compiler).
 *
 * > When defined with the `enum` keyword and constant numeric values (or no
 * > explicit values specified at all, which defaults to `0` for the first key
 * > and increments by `1` for each subsequent key), the TypeScript compiler
 * > auto-generates an implicit reverse-mapping from the values back to their
 * > respective keys.
 *
 * @example Constant enum definition
 * ```ts
 * enum Abc {
 *   B = 0,
 *   C = 1,
 * }
 * ```
 * @example Mixed-value enum definition (no reverse mapping)
 * ```ts
 * // Mixing string and numeric values in an enum definition will
 * // prevent the compiler from generating reverse mappings (since
 * // it only generates such mappings for constant numeric values).
 * enum Abc {
 *   B = 0,
 *   C = "c",
 * }
 * ```
 * @example Constant enum definition (implicit value assignment)
 * ```ts
 * // auto-generates a reverse mapping from 0 => B and 1 => C
 * enum Abc {
 *    B, // = 0
 *    C, // = 1
 * // "0" = "B",
 * // "1" = "C",
 * }
 * ```
 * @example Computed enum definition
 * ```ts
 * enum C {
 *   D = "e" + "f", // "ef"
 * }
 * ```
 */
export type Enum<T extends EnumLike = EnumLike> = EnumLike & T;

/** @internal */
export default isEnum;
